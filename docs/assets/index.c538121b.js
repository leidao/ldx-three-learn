var G=Object.defineProperty;var O=(m,e,t)=>e in m?G(m,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):m[e]=t;var w=(m,e,t)=>(O(m,typeof e!="symbol"?e+"":e,t),t);import{r as C,j as D}from"./index.c6e8682a.js";import{aq as N,V as P,ar as R,e as L,a8 as le,M as de,ai as ue,g as pe,as as fe,E as F,O as I,B as E,Z as q,L as U,F as z,Q as B,G as H,at as j,au as W,av as Z,aa as Y,C as V,aw as X,s as J,ax as Q,c as K}from"./index.e8d03d83.js";import{G as $}from"./GLTFLoader.8c8dc910.js";class b{static roundNumber(e,t){const s=Math.pow(10,t);return Math.round(e*s)/s}static sample(e){return e[Math.floor(Math.random()*e.length)]}static distanceToSquared(e,t){var s=e.x-t.x,i=e.y-t.y,r=e.z-t.z;return s*s+i*i+r*r}static isPointInPoly(e,t){for(var s=!1,i=-1,r=e.length,n=r-1;++i<r;n=i)(e[i].z<=t.z&&t.z<e[n].z||e[n].z<=t.z&&t.z<e[i].z)&&t.x<(e[n].x-e[i].x)*(t.z-e[i].z)/(e[n].z-e[i].z)+e[i].x&&(s=!s);return s}static isVectorInPolygon(e,t,s){var i=1e5,r=-1e5,n=[];return t.vertexIds.forEach(a=>{i=Math.min(s[a].y,i),r=Math.max(s[a].y,r),n.push(s[a])}),!!(e.y<r+.5&&e.y>i-.5&&this.isPointInPoly(n,e))}static triarea2(e,t,s){return(s.x-e.x)*(t.z-e.z)-(t.x-e.x)*(s.z-e.z)}static vequal(e,t){return this.distanceToSquared(e,t)<1e-5}static mergeVertices(e,t=1e-4){t=Math.max(t,Number.EPSILON);for(var s={},i=e.getIndex(),r=e.getAttribute("position"),n=i?i.count:r.count,a=0,o=[],h=[],u=Math.log10(1/t),p=Math.pow(10,u),l=0;l<n;l++){var c=i?i.getX(l):l,f="";f+=~~(r.getX(c)*p)+",",f+=~~(r.getY(c)*p)+",",(f+=~~(r.getZ(c)*p)+",")in s?o.push(s[f]):(h.push(r.getX(c)),h.push(r.getY(c)),h.push(r.getZ(c)),s[f]=a,o.push(a),a++)}const d=new E(new Float32Array(h),r.itemSize,r.normalized),g=new I;return g.setAttribute("position",d),g.setIndex(o),g}}class ee{constructor(e){this.content=[],this.scoreFunction=e}push(e){this.content.push(e),this.sinkDown(this.content.length-1)}pop(){const e=this.content[0],t=this.content.pop();return this.content.length>0&&(this.content[0]=t,this.bubbleUp(0)),e}remove(e){const t=this.content.indexOf(e),s=this.content.pop();t!==this.content.length-1&&(this.content[t]=s,this.scoreFunction(s)<this.scoreFunction(e)?this.sinkDown(t):this.bubbleUp(t))}size(){return this.content.length}rescoreElement(e){this.sinkDown(this.content.indexOf(e))}sinkDown(e){const t=this.content[e];for(;e>0;){const s=(e+1>>1)-1,i=this.content[s];if(!(this.scoreFunction(t)<this.scoreFunction(i)))break;this.content[s]=t,this.content[e]=i,e=s}}bubbleUp(e){const t=this.content.length,s=this.content[e],i=this.scoreFunction(s);for(;;){const r=e+1<<1,n=r-1;let a,o=null;if(n<t&&(a=this.scoreFunction(this.content[n]),a<i&&(o=n)),r<t&&this.scoreFunction(this.content[r])<(o===null?i:a)&&(o=r),o===null)break;this.content[e]=this.content[o],this.content[o]=s,e=o}}}class te{constructor(){this.portals=[]}push(e,t){t===void 0&&(t=e),this.portals.push({left:e,right:t})}stringPull(){const e=this.portals,t=[];let s,i,r,n=0,a=0,o=0;s=e[0].left,i=e[0].left,r=e[0].right,t.push(s);for(let h=1;h<e.length;h++){const u=e[h].left,p=e[h].right;if(b.triarea2(s,r,p)<=0){if(!(b.vequal(s,r)||b.triarea2(s,i,p)>0)){t.push(i),s=i,n=a,i=s,r=s,a=n,o=n,h=n;continue}r=p,o=h}if(b.triarea2(s,i,u)>=0){if(!(b.vequal(s,i)||b.triarea2(s,r,u)<0)){t.push(r),s=r,n=o,i=s,r=s,a=n,o=n,h=n;continue}i=u,a=h}}return t.length!==0&&b.vequal(t[t.length-1],e[e.length-1].left)||t.push(e[e.length-1].left),this.path=t,t}}class x{constructor(){this.zones={}}static createZone(e,t=1e-4){return class{static buildZone(s,i){const r=this._buildNavigationMesh(s,i),n={};r.vertices.forEach(o=>{o.x=b.roundNumber(o.x,2),o.y=b.roundNumber(o.y,2),o.z=b.roundNumber(o.z,2)}),n.vertices=r.vertices;const a=this._buildPolygonGroups(r);return n.groups=new Array(a.length),a.forEach((o,h)=>{const u=new Map;o.forEach((l,c)=>{u.set(l,c)});const p=new Array(o.length);o.forEach((l,c)=>{const f=[];l.neighbours.forEach(y=>f.push(u.get(y)));const d=[];l.neighbours.forEach(y=>d.push(this._getSharedVerticesInOrder(l,y)));const g=new P(0,0,0);g.add(n.vertices[l.vertexIds[0]]),g.add(n.vertices[l.vertexIds[1]]),g.add(n.vertices[l.vertexIds[2]]),g.divideScalar(3),g.x=b.roundNumber(g.x,2),g.y=b.roundNumber(g.y,2),g.z=b.roundNumber(g.z,2),p[c]={id:c,neighbours:f,vertexIds:l.vertexIds,centroid:g,portals:d}}),n.groups[h]=p}),n}static _buildNavigationMesh(s,i){return s=b.mergeVertices(s,i),this._buildPolygonsFromGeometry(s)}static _spreadGroupId(s){let i=new Set([s]);for(;i.size>0;){const r=i;i=new Set,r.forEach(n=>{n.group=s.group,n.neighbours.forEach(a=>{a.group===void 0&&i.add(a)})})}}static _buildPolygonGroups(s){const i=[];return s.polygons.forEach(r=>{r.group!==void 0?i[r.group].push(r):(r.group=i.length,this._spreadGroupId(r),i.push([r]))}),i}static _buildPolygonNeighbours(s,i){const r=new Set,n=i[s.vertexIds[1]],a=i[s.vertexIds[2]];return i[s.vertexIds[0]].forEach(o=>{o!==s&&(n.includes(o)||a.includes(o))&&r.add(o)}),n.forEach(o=>{o!==s&&a.includes(o)&&r.add(o)}),r}static _buildPolygonsFromGeometry(s){const i=[],r=[],n=s.attributes.position,a=s.index,o=[];for(let h=0;h<n.count;h++)r.push(new P().fromBufferAttribute(n,h)),o[h]=[];for(let h=0;h<s.index.count;h+=3){const u=a.getX(h),p=a.getX(h+1),l=a.getX(h+2),c={vertexIds:[u,p,l],neighbours:null};i.push(c),o[u].push(c),o[p].push(c),o[l].push(c)}return i.forEach(h=>{h.neighbours=this._buildPolygonNeighbours(h,o)}),{polygons:i,vertices:r}}static _getSharedVerticesInOrder(s,i){const r=s.vertexIds,n=r[0],a=r[1],o=r[2],h=i.vertexIds,u=h.includes(n),p=h.includes(a),l=h.includes(o);return u&&p&&l?Array.from(r):u&&p?[n,a]:p&&l?[a,o]:u&&l?[o,n]:(console.warn("Error processing navigation mesh neighbors; neighbors with <2 shared vertices found."),[])}}.buildZone(e,t)}setZoneData(e,t){this.zones[e]=t}getRandomNode(e,t,s,i){if(!this.zones[e])return new P;s=s||null,i=i||0;const r=[];return this.zones[e].groups[t].forEach(n=>{s&&i?b.distanceToSquared(s,n.centroid)<i*i&&r.push(n.centroid):r.push(n.centroid)}),b.sample(r)||new P}getClosestNode(e,t,s,i=!1){const r=this.zones[t].vertices;let n=null,a=1/0;return this.zones[t].groups[s].forEach(o=>{const h=b.distanceToSquared(o.centroid,e);h<a&&(!i||b.isVectorInPolygon(e,o,r))&&(n=o,a=h)}),n}findPath(e,t,s,i){const r=this.zones[s].groups[i],n=this.zones[s].vertices,a=this.getClosestNode(e,s,i,!0),o=this.getClosestNode(t,s,i,!0);if(!a||!o)return null;const h=class{static init(c){for(let f=0;f<c.length;f++){const d=c[f];d.f=0,d.g=0,d.h=0,d.cost=1,d.visited=!1,d.closed=!1,d.parent=null}}static cleanUp(c){for(let f=0;f<c.length;f++){const d=c[f];delete d.f,delete d.g,delete d.h,delete d.cost,delete d.visited,delete d.closed,delete d.parent}}static heap(){return new ee(function(c){return c.f})}static search(c,f,d){this.init(c);const g=this.heap();for(g.push(f);g.size()>0;){const y=g.pop();if(y===d){let v=y;const M=[];for(;v.parent;)M.push(v),v=v.parent;return this.cleanUp(M),M.reverse()}y.closed=!0;const _=this.neighbours(c,y);for(let v=0,M=_.length;v<M;v++){const k=_[v];if(k.closed)continue;const A=y.g+k.cost,S=k.visited;if(!S||A<k.g){if(k.visited=!0,k.parent=y,!k.centroid||!d.centroid)throw new Error("Unexpected state");k.h=k.h||this.heuristic(k.centroid,d.centroid),k.g=A,k.f=k.g+k.h,S?g.rescoreElement(k):g.push(k)}}}return[]}static heuristic(c,f){return b.distanceToSquared(c,f)}static neighbours(c,f){const d=[];for(let g=0;g<f.neighbours.length;g++)d.push(c[f.neighbours[g]]);return d}}.search(r,a,o),u=function(c,f){for(var d=0;d<c.neighbours.length;d++)if(c.neighbours[d]===f.id)return c.portals[d]},p=new te;p.push(e);for(let c=0;c<h.length;c++){const f=h[c],d=h[c+1];if(d){const g=u(f,d);p.push(n[g[0]],n[g[1]])}}p.push(t),p.stringPull();const l=p.path.map(c=>new P(c.x,c.y,c.z));return l.shift(),l}}x.prototype.getGroup=function(){const m=new N;return function(e,t,s=!1){if(!this.zones[e])return null;let i=null,r=Math.pow(50,2);const n=this.zones[e];for(let a=0;a<n.groups.length;a++){const o=n.groups[a];for(const h of o){if(s&&(m.setFromCoplanarPoints(n.vertices[h.vertexIds[0]],n.vertices[h.vertexIds[1]],n.vertices[h.vertexIds[2]]),Math.abs(m.distanceToPoint(t))<.01)&&b.isPointInPoly([n.vertices[h.vertexIds[0]],n.vertices[h.vertexIds[1]],n.vertices[h.vertexIds[2]]],t))return a;const u=b.distanceToSquared(h.centroid,t);u<r&&(i=a,r=u)}}return i}}(),x.prototype.clampStep=function(){const m=new P,e=new N,t=new R,s=new P;let i,r,n=new P;return function(a,o,h,u,p,l){const c=this.zones[u].vertices,f=this.zones[u].groups[p],d=[h],g={};g[h.id]=0,i=void 0,n.set(0,0,0),r=1/0,e.setFromCoplanarPoints(c[h.vertexIds[0]],c[h.vertexIds[1]],c[h.vertexIds[2]]),e.projectPoint(o,m),s.copy(m);for(let y=d.pop();y;y=d.pop()){t.set(c[y.vertexIds[0]],c[y.vertexIds[1]],c[y.vertexIds[2]]),t.closestPointToPoint(s,m),m.distanceToSquared(s)<r&&(i=y,n.copy(m),r=m.distanceToSquared(s));const _=g[y.id];if(!(_>2))for(let v=0;v<y.neighbours.length;v++){const M=f[y.neighbours[v]];M.id in g||(d.push(M),g[M.id]=_+1)}}return l.copy(n),i}}();const we={PLAYER:new L(15631215).convertSRGBToLinear().getHex(),TARGET:new L(14469912).convertSRGBToLinear().getHex(),PATH:new L(41903).convertSRGBToLinear().getHex(),WAYPOINT:new L(41903).convertSRGBToLinear().getHex(),CLAMPED_STEP:new L(14472114).convertSRGBToLinear().getHex(),CLOSEST_NODE:new L(4417387).convertSRGBToLinear().getHex()};const T=new WeakMap;class se extends U{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,t,s,i){const r=new z(this.manager);r.setPath(this.path),r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,n=>{const a={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(n,a).then(t).catch(i)},s,i)}decodeDracoFile(e,t,s,i){const r={attributeIDs:s||this.defaultAttributeIDs,attributeTypes:i||this.defaultAttributeTypes,useUniqueIDs:!!s};this.decodeGeometry(e,r).then(t)}decodeGeometry(e,t){for(const o in t.attributeTypes){const h=t.attributeTypes[o];h.BYTES_PER_ELEMENT!==void 0&&(t.attributeTypes[o]=h.name)}const s=JSON.stringify(t);if(T.has(e)){const o=T.get(e);if(o.key===s)return o.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let i;const r=this.workerNextTaskID++,n=e.byteLength,a=this._getWorker(r,n).then(o=>(i=o,new Promise((h,u)=>{i._callbacks[r]={resolve:h,reject:u},i.postMessage({type:"decode",id:r,taskConfig:t,buffer:e},[e])}))).then(o=>this._createGeometry(o.geometry));return a.catch(()=>!0).then(()=>{i&&r&&this._releaseTask(i,r)}),T.set(e,{key:s,promise:a}),a}_createGeometry(e){const t=new I;e.index&&t.setIndex(new E(e.index.array,1));for(let s=0;s<e.attributes.length;s++){const i=e.attributes[s],r=i.name,n=i.array,a=i.itemSize;t.setAttribute(r,new E(n,a))}return t}_loadLibrary(e,t){const s=new z(this.manager);return s.setPath(this.decoderPath),s.setResponseType(t),s.setWithCredentials(this.withCredentials),new Promise((i,r)=>{s.load(e,i,void 0,r)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then(s=>{const i=s[0];e||(this.decoderConfig.wasmBinary=s[1]);const r=ne.toString(),n=["/* draco decoder */",i,"","/* worker */",r.substring(r.indexOf("{")+1,r.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([n]))}),this.decoderPending}_getWorker(e,t){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const i=new Worker(this.workerSourceURL);i._callbacks={},i._taskCosts={},i._taskLoad=0,i.postMessage({type:"init",decoderConfig:this.decoderConfig}),i.onmessage=function(r){const n=r.data;switch(n.type){case"decode":i._callbacks[n.id].resolve(n);break;case"error":i._callbacks[n.id].reject(n);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+n.type+'"')}},this.workerPool.push(i)}else this.workerPool.sort(function(i,r){return i._taskLoad>r._taskLoad?-1:1});const s=this.workerPool[this.workerPool.length-1];return s._taskCosts[e]=t,s._taskLoad+=t,s})}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}function ne(){let m,e;onmessage=function(n){const a=n.data;switch(a.type){case"init":m=a.decoderConfig,e=new Promise(function(u){m.onModuleLoaded=function(p){u({draco:p})},DracoDecoderModule(m)});break;case"decode":const o=a.buffer,h=a.taskConfig;e.then(u=>{const p=u.draco,l=new p.Decoder,c=new p.DecoderBuffer;c.Init(new Int8Array(o),o.byteLength);try{const f=t(p,l,c,h),d=f.attributes.map(g=>g.array.buffer);f.index&&d.push(f.index.array.buffer),self.postMessage({type:"decode",id:a.id,geometry:f},d)}catch(f){console.error(f),self.postMessage({type:"error",id:a.id,error:f.message})}finally{p.destroy(c),p.destroy(l)}});break}};function t(n,a,o,h){const u=h.attributeIDs,p=h.attributeTypes;let l,c;const f=a.GetEncodedGeometryType(o);if(f===n.TRIANGULAR_MESH)l=new n.Mesh,c=a.DecodeBufferToMesh(o,l);else if(f===n.POINT_CLOUD)l=new n.PointCloud,c=a.DecodeBufferToPointCloud(o,l);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!c.ok()||l.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+c.error_msg());const d={index:null,attributes:[]};for(const g in u){const y=self[p[g]];let _,v;if(h.useUniqueIDs)v=u[g],_=a.GetAttributeByUniqueId(l,v);else{if(v=a.GetAttributeId(l,n[u[g]]),v===-1)continue;_=a.GetAttribute(l,v)}d.attributes.push(i(n,a,l,g,y,_))}return f===n.TRIANGULAR_MESH&&(d.index=s(n,a,l)),n.destroy(l),d}function s(n,a,o){const u=o.num_faces()*3,p=u*4,l=n._malloc(p);a.GetTrianglesUInt32Array(o,p,l);const c=new Uint32Array(n.HEAPF32.buffer,l,u).slice();return n._free(l),{array:c,itemSize:1}}function i(n,a,o,h,u,p){const l=p.num_components(),f=o.num_points()*l,d=f*u.BYTES_PER_ELEMENT,g=r(n,u),y=n._malloc(d);a.GetAttributeDataArrayForAllPoints(o,p,g,d,y);const _=new u(n.HEAPF32.buffer,y,f).slice();return n._free(y),{name:h,array:_,itemSize:l}}function r(n,a){switch(a){case Float32Array:return n.DT_FLOAT32;case Int8Array:return n.DT_INT8;case Int16Array:return n.DT_INT16;case Int32Array:return n.DT_INT32;case Uint8Array:return n.DT_UINT8;case Uint16Array:return n.DT_UINT16;case Uint32Array:return n.DT_UINT32}}}class ie{constructor(e){w(this,"object");w(this,"pathfinder");w(this,"name","");w(this,"actionName","");w(this,"animations",{});w(this,"app");w(this,"speed");w(this,"calculatedPath");w(this,"waypoints");w(this,"quaternion",new B);w(this,"pathLines");w(this,"navMeshGroup",new H);w(this,"pathColor",new L(16777215));w(this,"showPath",!1);w(this,"dead",!1);w(this,"ZONE","");w(this,"mixer");w(this,"curAction");this.name=e.name||"NPC",this.animations={},this.object=e.object,e.app.viewer.scene.add(e.object),this.showPath=e.showPath||!1,this.waypoints=e.waypoints||[],this.speed=e.speed,this.app=e.app,e.app.pathfinder&&(this.pathfinder=e.app.pathfinder,this.ZONE=e.zone,this.navMeshGroup=this.pathfinder.getGroup(this.ZONE,this.object.position));const t=this.object.position.clone();t.z+=10,this.object.lookAt(t),e.animations&&(this.mixer=new j(e.object),e.animations.forEach(s=>{this.animations[s.name.toLowerCase()]=s}))}get randomWaypoint(){const e=Math.floor(Math.random()*this.waypoints.length);return this.waypoints[e]}set action(e){if(this.actionName==e.toLowerCase())return;const t=this.animations[e.toLowerCase()];if(t!==void 0){const s=this.mixer.clipAction(t);e=="shot"&&(s.clampWhenFinished=!0,s.setLoop(W,Z)),s.reset();const i=this.actionName=="shot";this.actionName=e.toLowerCase(),s.play(),this.curAction&&(i?this.curAction.enabled=!1:this.curAction.crossFadeTo(s,.5,!0)),this.curAction=s}}setTargetDirection(e){const t=this.object;e.y=t.position.y;const s=t.quaternion.clone();t.lookAt(e),this.quaternion=t.quaternion.clone(),t.quaternion.copy(s)}newPath(e){const t=this.object;if(!this.pathfinder){this.calculatedPath=[e.clone()],this.setTargetDirection(e.clone()),this.action="walking";return}if(this.calculatedPath=this.pathfinder.findPath(t.position,e,this.ZONE,this.navMeshGroup),this.calculatedPath&&this.calculatedPath.length>0){if(this.action="walking",this.setTargetDirection(this.calculatedPath[0].clone()),this.showPath){const s=new F({color:this.pathColor,linewidth:2}),i=[t.position];this.calculatedPath.forEach(n=>{i.push(n.clone())});const r=new I().setFromPoints(i);this.pathLines=new q(r,s),this.app.viewer.scene.add(this.pathLines)}}else if(this.action="idle",this.pathfinder){const s=this.pathfinder.getClosestNode(t.position,this.ZONE,this.navMeshGroup),i=new P;this.pathfinder.clampStep(t.position,e.clone(),s,this.ZONE,this.navMeshGroup,i),this.pathLines&&this.app.viewer.scene.remove(this.pathLines)}}update(e){const t=this.speed,s=this.object;if(this.mixer&&this.mixer.update(e),this.calculatedPath&&this.calculatedPath.length>0){const i=this.calculatedPath[0],r=i.clone().sub(s.position);let n=r.lengthSq()<.01;if(n)this.calculatedPath.shift(),this.calculatedPath.length===0?(this.waypoints!==void 0&&this.newPath(this.randomWaypoint),s.position.copy(i),this.action="idle"):this.setTargetDirection(i.clone());else{const a=s.position.distanceToSquared(i);r.normalize(),this.quaternion&&s.quaternion.slerp(this.quaternion,.1),s.position.add(r.multiplyScalar(e*t)),n=s.position.distanceToSquared(i)>a}}else!this.dead&&this.waypoints!==void 0&&this.newPath(this.randomWaypoint)}}class re{constructor(e){w(this,"game");w(this,"viewer");w(this,"gltf");w(this,"npcs",[]);w(this,"waypoints",[]);this.game=e,this.viewer=e.viewer,this.load(),this.initMouseHandler()}get randonWaypoint(){const e=Math.floor(Math.random()*this.waypoints.length);return this.waypoints[e]}load(){this.game.gltfLoader.setPath("factory/glb/");const e=new se(this.viewer.loadmanager);e.setDecoderPath("factory/draco/"),this.game.gltfLoader.setDRACOLoader(e),this.game.gltfLoader.load("swat-guy2.glb",t=>{this.game.pathfinder?this.initNPCs(t):this.gltf=t},t=>{this.viewer.onProgress("swat-guy2.glb",t)})}initNPCs(e=this.gltf){const t=[e];this.waypoints=this.game.waypoints,this.npcs=[];for(let s=0;s<3;s++)t.push(this.cloneGLTF(e));t.forEach(s=>{const i=s.scene;i.traverse(a=>{a.isMesh&&(a.castShadow=!0)});const r={object:i,speed:.8,animations:s.animations,waypoints:this.waypoints,app:this.game,showPath:!1,zone:"factory",name:"swat-guy"},n=new ie(r);n.object.position.copy(this.randonWaypoint),n.newPath(this.randonWaypoint),this.npcs.push(n)})}cloneGLTF(e){const t={animations:e.animations,scene:e.scene.clone(!0)},s={};e.scene.traverse(n=>{n.isSkinnedMesh&&(s[n.name]=n)});const i={},r={};t.scene.traverse(n=>{n.isBone&&(i[n.name]=n),n.isSkinnedMesh&&(r[n.name]=n)});for(const n in s){const o=s[n].skeleton,h=r[n],u=[];for(let p=0;p<o.bones.length;++p){const l=i[o.bones[p].name];u.push(l)}h.bind(new Y(u,o.boneInverses),h.matrixWorld)}return t}initMouseHandler(){const e=this.viewer.renderer.domElement,t={x:0,y:0},{width:s,height:i,left:r,top:n}=e.getBoundingClientRect(),a=o=>{t.x=(o.clientX-r)/s*2-1,t.y=-((o.clientY-n)/i)*2+1,this.viewer.raycaster.setFromCamera(t,this.viewer.camera);const h=this.viewer.raycaster.intersectObject(this.game.navMesh);if(h.length>0){const u=h[0].point;this.npcs[0].newPath(u)}};e.addEventListener("click",a,!1)}update(e){this.npcs&&this.npcs.forEach(t=>t.update(e))}}class oe{constructor(e){w(this,"clock");w(this,"viewer");w(this,"gltfLoader");w(this,"factory");w(this,"fans",[]);w(this,"navMesh");w(this,"npcHandler");w(this,"pathfinder");w(this,"waypoints",[]);w(this,"update",()=>{const e=this.clock.getDelta();this.fans.forEach(t=>t.rotateY(e)),this.npcHandler&&this.npcHandler.update(e),this.render()});this.viewer=e,e.useLoadingManager(),this.clock=new V,this.gltfLoader=new $(e.loadmanager),this.init(),this.loadFactory(),this.npcHandler=new re(this)}render(){this.viewer.render()}init(){this.viewer.scene.background=new L(2102544),this.viewer.scene.fog=new X(2102544,100,200),this.viewer.renderer.outputEncoding=J,this.viewer.camera.position.set(0,60,20),this.viewer.camera.lookAt(0,0,-10),this.viewer.renderer.shadowMap.enabled=!0;const t=new Q(16777215,12303359,1);this.viewer.scene.add(t),this.viewer.directionalLight.position.set(0,20,20),this.viewer.directionalLight.target.position.set(-2,0,0),this.viewer.directionalLight.castShadow=!0,this.viewer.directionalLight.shadow.mapSize.set(1024,512),this.viewer.directionalLight.shadow.camera.near=.5,this.viewer.directionalLight.shadow.camera.far=50;const s=30;this.viewer.directionalLight.shadow.camera.left=-s,this.viewer.directionalLight.shadow.camera.right=s,this.viewer.directionalLight.shadow.camera.top=s,this.viewer.directionalLight.shadow.camera.bottom=-s*.25}loadFactory(){this.gltfLoader.setPath("factory/glb/"),this.gltfLoader.load("factory2.glb",e=>{this.factory=e.scene,this.viewer.scene.add(this.factory),this.fans=[],this.factory.traverse(t=>{t.isMesh&&(t.name==="NavMesh"?(this.navMesh=t,this.navMesh.geometry.rotateX(Math.PI/2),this.navMesh.quaternion.identity(),this.navMesh.position.set(0,0,0),t.material.visible=!1):t.name.includes("fan")?this.fans.push(t):t.material.name.includes("elements2")||t.material.name.includes("elements5")||t.material.name.includes("terrain")?t.castShadow=!0:t.material.name.includes("sand")?t.receiveShadow=!0:t.material.name.includes("elements1")?(t.castShadow=!0,t.receiveShadow=!0):t.parent.name.includes("main")&&(t.castShadow=!0))}),this.viewer.scene.add(this.navMesh),this.initPathfinding(this.navMesh),this.render()},e=>{this.viewer.onProgress("factory.glb",e)})}initPathfinding(e){this.waypoints=[new P(17.73372016326552,.39953298254866443,-.7466724607286782),new P(20.649478054772402,.04232912113775987,-18.282935518174437),new P(11.7688416798274,.11264635905666916,-23.23102176233945),new P(-3.111551689570482,.18245423057147991,-22.687392486867505),new P(-13.772447796604245,.1260277454451636,-23.12237117145656),new P(-20.53385139415452,.0904175187063471,-12.467546107992108),new P(-18.195950790753532,.17323640676321908,-.9593366354062719),new P(-6.603208729295872,.015786387893574227,-12.265553884212125)],this.pathfinder=new x,this.pathfinder.setZoneData("factory",x.createZone(e.geometry,.02)),this.npcHandler.gltf!==void 0&&this.npcHandler.initNPCs()}}const me=()=>{const m=C.exports.useRef(null);return C.exports.useEffect(()=>{if(!m.current)return;const e=new K(m.current);e.useOrbitControls(),e.listen();const t=new oe(e);let s;const i=()=>{t.update(),s=requestAnimationFrame(i)};return i(),()=>{cancelIdleCallback(s)}},[]),D("div",{className:"w-100% h-100% relative",children:D("div",{className:"gunplay w-100% h-100%",ref:m})})};export{me as default};
